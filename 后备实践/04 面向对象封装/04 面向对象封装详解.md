# 面向对象封装详解

## 前言

本篇博文是面向对象封装的小结，仅做自己记录之用。

目录

1 [作用 & 实现思路](#1)

2 [具体实现](#2)


## <span id="1">一 作用 & 实现思路</span>

1 面向对象的作用: 可用于解决跨文件的重复代码的问题

2 实现思路

1 封装 view部分: 一个构造函数即可


2 封装 model部分，返回的是一个对象

S1 修改 读取数据的 参数传入方式

S2 修改 传入数据的 参数传入方式


3 封装 controller部分,自动处理view、model + 调用bindEvents方法等

S0 拷贝除了init属性方法之外的 所有传入crtl对象的 属性和方法

S1 获取传入的ctrl对象实例的 init方法(独特部分)

S2 封装一个 ctlObject对象，它用于封装跨文件的ctrl部分的公有代码，包括:
  
  - view + model的声明和赋值(在init方法内)

  - 调用model部分的init方法
  
  - 调用传入的ctrl实例的init方法

  - 调用bindEvents方法


## <span id="2">二 具体实现</span>

```js
// 1 封装 view部分,view.js文件: 一个构造函数
window.View = function(selector){
  return document.querySelector(selector)
}

// 2 封装model部分,model.js文件
window.model = function(options){
  let table = options.tableName
  return {
    // 初始化数据库对象
    init: function(){
      var APP_ID = 'Uk1e5CaSFbxXzJnvV8T3eXP3-gzGzoHsz'
      var APP_KEY = '2aPToLfp5W2amgYWaB1i5d5x'
      AV.init({ appId: APP_ID, appKey: APP_KEY })
    },
    // 读取数据
    fetch: function(){
      var query = new AV.Query(table)
      return query.find()               // 返回一个Promise对象
    },
    // 存入数据
    save: function(dataobject){
      let CreateTable = AV.Object.extend(table)
      let createtable = new CreateTable()
      // 返回一个Promise对象
      return createtable.save(dataobject)
    }

  }
}

// 3 封装 controller部分,自动处理view、model + 调用bindEvents方法等
window.Controller = function (options) {
  let ctrlInit = options.init

  let ctlObject = {
    view: null,      //  声明参数变量
    model: null,
    //ctrlInit: ctrlInit,
    init: function (view, model) {
      this.view = view
      this.model = model

      this.model.init()
      ctrlInit.call(this,view)       // {this.form} 对象方法里还嵌套一层this
      this.bindEvents()
    }
  }

  for (let key in options) {
    if (key !== 'init') {
      ctlObject[key] = options[key]
    }
  }

  return ctlObject
}
```