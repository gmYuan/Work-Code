# 防抖和节流

## 目录

1 [防抖](#1)

  - [1.1 需求描述](#1.1)

  - [1.2 代码实现](#1.2)

  - [1.3 其他功能实现](#1.3)


2 [节流](#1)

  - [2.1 需求描述](#2.1)

  - [2.2 代码实现](#2.2)

  - [2.3 其他功能实现](#2.3)



## <span id="1">一  防抖 </span>

### <span id="1.1"> 1.1 需求描述 </span>

1 Q: 什么是防抖

A: 防抖是提高性能的一种方式，常用于优化 一些触发频繁的事件回调

S1 未优化情况下，有一些事件会频繁触发，如AJAX+查询请求/ scroll事件/ onmousemove事件等

S2 防抖的含义是: 让事件回调只有在 最后一次事件触发后的n秒 才执行，中间的触发事件会不断重置响应

S3 类似于招数读条，如果中间再次搓大(触发事件)，则重新读条(重置时间)，直到读满后才会 调用回调响应


2 Q: 根据需求描述，实现防抖的 逻辑步骤是什么

A: S1 接受2个参数: 事件的响应回调 + 不连续触发事件的 最小时间间隔wait(读条时间)

S2 防抖是对 事件的回调处理，所以 返回的是一个函数

S3 返回的函数内部是一个定时器，这样当触发事件时，就会触发 返回函数内部的定时器

S4 当连续触发事件时，就会连续设定定时器，所以要清除之前的定时器 + 重新设置定时器(重新读条) 



### <span id="1.2"> 1.2 代码实现 </span>

1 Q: 根据逻辑步骤，请写出 防抖的 实现代码

S2 实现代码如下

```js
// 第一版
function debounce(func, wait){
  let timer
  return function() {
    clearTimeout(timer)     // 传入值为undefined时也不会有异常，语法特性
    timer = setTimeout(func, wait)  // timer闹钟标识是同步代码，所以会立刻返回一个编号
  }
}

container.onmousemove = debounce(moveAction, 1000) 

// 分析如下

// A1 调用debounce后，会返回一个匿名函数绑定到 鼠标移动事件上

// A2 第一次移动时触发事件，调用匿名函数fn, 设定定时器timer = 1
// A3 紧接着第二移动触发事件， 清除定时器1(还未把func加入队列) + 重新设定timer = 2
......

// A4 当第5次触发移动事件的 时间间隔大于wait时，则 moveAction已被 成功加入队列

// 综上，所以实质是利用 clearTimeout的机制: 未加入队列可删除闹钟 + 已加入队列的闹钟删除也无所谓
```

2 Q: 以上代码有什么问题么？如何优化解决

A: 丢失了this指向和事件对象

S1 如果直接绑定事件回调函数，其this指向 注册监听事件的元素对象(值是固定不变的)

S2 如果直接绑定事件回调函数，其回调函数中会可以传入一个事件对象e

S3 而因为throttle内 使用了setTimeout来调用回调func，所以以上两个值都被丢失了

S4 优化解决的方法是使用 闭包 + call 来调用func

```js
// 第二版
function throttle(func, wait){
  let timer

  return function(){    // 返回的匿名函数被注册为事件的 回调函数，所以会被传入this和e
    let context = this
    let args = arguments
    clearTimeout(timer)

    timer = setTimeout( function(){
      func.call(context, args)
    }, wait)
  }

} 
```

### <span id="1.3"> 1.3 其他功能实现 </span>

1 Q: 防抖还有什么其他功能么

A: 以上基本是防抖的主要功能实现了，以下是伢羽大神后续版本的代码分析，可结合他的博客来看

```js
// 第4版  新增 第一次触发事件时立刻执行一次函数，然后停止触发n秒后，才可以重新触发执行

function debounce(func, wait,immediate){
  let timer
  return function(){
    let context = this
    let args = arguments
    if (timer){ clearTimeout(timer)}

    if (immediate){
      let callNow = !timer
      timer = setTimeout(function(){
        timer = null
      },wait)

      if (callNow) func.call(context, args)
    } else {
      timer = setTimeout(function(){
        func.call(context, args)
      }, wait)
    }

  } // 对应匿名返回函数
}


// 过程分析

// A1 immediate为false时，则和之前一样，连续触发时 会取消定时器 + 新建定时器

// A2 immediate为true时 + 第一次触发事件:
//      timer为undefined + callNow为true + timer定时器1 +  执行真正的回调函数
//        定时器1的作用是: 预设间隔时间后，timer值变为null


// A2 immediate为true时 + 第二次触发事件(间隔 < wait时):
//      timer为1 & 其异步设置被取消 + callNow为false + timer定时器2 + 不执行真正的回调函数
 

// A3 immediate为true时 + 第三次触发事件(间隔 > wait时):
//      timer被设置为null + callNow为true + timer定时器3 +  执行真正的回调函数
```


## <span id="2">二 节流 </span>

### <span id="2.1"> 2.1 需求描述 </span>

1 Q: 什么是节流

A: 节流同样是用于优化 频繁触发的事件性能 

S1 防抖的核心是 触发事件后不断重设响应，而节流的核心是 触发事件后一段时间内只设置一次响应

S2 可以把节流理解为固定频率的子弹发射，一段时间内按多次射击，也只会发射一颗子弹


### <span id="2.2"> 2.2 代码实现 </span>

1 Q: 如何用时间戳方式实现节流

A: 代码实现如下

```js
function throttle(func, wait){
  let prev = 0
  let context, args    // 在这里声明，不用每次返回匿名处理函数时，就都创建一个新变量

  return function(){
    context = this
    args = arguments
    let now = + new Date()  
    if (now - prev > wait){
      func.call(context,args)
      prev = now
    }
  }

}

// 代码分析
// A1 第一次触发时，判断 当前时间，未到间隔时间则无响应

// A2 第二次触发 + 满足间隔，则触发响应 + 把当前时间作为之前时间

// A3 特点是初次会触发(prev为0) + 4.2s时不会触发(不满足1s的间隔)
```

2 Q: 如何用定时器方式 实现节流

A: 代码实现如下

```js
function throttle(func,wait){
  let context,args
  let timer, noOld
  
  return function(){
    context = this
    args = arguments
    noOld = !timer

    if (noOld) {
      timer = setTimeout(function(){
        func.call(context,args)
        timer = null
       },wait)
    }
 
  }// 对应匿名函数

}

// 代码分析
// A1 第一次触发时，timer为undefined + noOld为ture + 设置定时器timer=1
        定时器的作用是 触发回调 + 设置timer为null

// A2 第二次触发 + 不满足间隔: timer为1 + noOld为false,不触发回调响应

// A3 第三次触发 + 满足间隔: 已执行回调 + timer被设置为null + 设置定时器timer=2

// A4 停止触发后，由于之前定时器的延迟效果，会再执行一次响应

```

综上，

时间戳方法: 事件会立刻执行，停止触发后不会再执行响应回调

定时器方法: 事件会在n秒后第一次执行（定时器原因)，停止触发后会再执行一次响应回调


3 Q: 如何用 时间戳+定时器 实现节流

A: 代码实现如下





function throttle(func, wait) {
    var timeout, context, args, result;
    var previous = 0;

    var later = function() {
        previous = +new Date();
        timeout = null;
        func.apply(context, args)
    };

    var throttled = function() {
        var now = +new Date();
       
        var remaining = wait - (now - previous)   //下次触发 func 剩余的时间
        context = this;
        args = arguments

         // 如果没有剩余的时间了或者你改了系统时间
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
        } else if (!timeout) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;    // 返回的这个函数就是 事件回调响应
}



// 过程分析

// A1 第1次触发事件: timer为undefined + remaing <=0 + 更新时间 + 立刻调用回调响应

// A2.1 第2次触发事件+未到间隔时间(remaining > 0)+之前未实例timer: timer1设置定时器
//       timer1的定时器作用是: 在剩余时间后 调用later函数
//       later的操作是: 更新当前时间 + timer变为null + 调用回调函数   


// A2.2 第2次触发事件+ 已到间隔时间 +之前未实例timer: 更新当前时间 + 调用回调函数 


// A3 第3次触发事件+已到间隔时间+已存在timer1: 清除定时器 + 重置timer为null
//        之后 更新当前时间  + 调用回调函数   

